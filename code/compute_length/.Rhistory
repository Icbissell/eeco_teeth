chas.depths.pointer <- as.numeric(unlist(density_depths[, "Mean_depth"]))
chas.density.pointer <- as.numeric(unlist(density_depths[, "Dry_density"]))
chas.depths.int <- as.numeric(unlist(density_depths[, "Wanted_depth"]))
head(chas.density.pointer)
chas.density.pointer
chas.depths.int
chas.density.pointer[93]
chas.density.pointer[92]
chas.density.pointer <- chas.density.pointer[1:92]
chas.depths.pointer <- chas.depths.pointer[1.92]
chas.depths.pointer
chas.density.pointer <- as.numeric(unlist(density_depths[, "Dry_density"]))
chas.depths.pointer <- chas.depths.pointer[1:92]
chas.depths.pointer
chas.depths.pointer <- as.numeric(unlist(density_depths[, "Mean_depth"]))
chas.depths.pointer <- chas.depths.pointer[1:92]
chas.depths.pointer
age.model <- ageDepth.fn(chas.density.pointer, chas.depths.pointer, chas.depths.int)
age.model <- ageDepth.fn(chas.density.pointer, chas.depths.pointer, chas.depths.int)
age.model <- ageDepth.fn(chas.density.pointer, chas.depths.pointer, chas.depths.int)
force(xlab)
chas.depths.pointer
# Generate a random age-depth model - this would be replaced by reading in a csv of age-depth pointers
ages.pointer <- sort(rnorm(20))
#####################################################
#                                                   #
#                 ageDepth.fn                       #
#                                                   #
#   Takes an age model (age/depth pointers) and     #
#   linearly interpolates ages between points for   #
#   a given set of depths (sample depths) based     #
#   on the pointers.                                #
#                                                   #
#####################################################
ageDepth.fn <- function(ages.pointer, depths.pointer, depths.out, plot.out = FALSE) {
agemodel <- approx(x = depths.pointer, y = ages.pointer, xout = depths.out)
if(plot.out == TRUE) {
plot(agemodel, xlab = 'depth', ylab = 'age')
points(depths.pointer, ages.pointer, pch = 16, col = 'red')
}
names(agemodel) <- c('depth', 'age')
return(agemodel)
}
###########################
#                         #
#       Example use       #
#                         #
###########################
# Generate a random age-depth model - this would be replaced by reading in a csv of age-depth pointers
ages.pointer <- sort(rnorm(20))
depths.pointer <- sort(rnorm(20))
# generate a set of "depths out" - this is an evenly-distributed sample set, for visualization, but it can be anything
depths.out = seq(from=min(depths.pointer), to = max(depths.pointer), length.out = 50)
# Generate the age-depth model
age.model <- ageDepth.fn(ages.pointer = ages.pointer, depths.pointer = depths.pointer, depths.out = depths.out, plot.out = TRUE)
# # Save the age.depth model output
# writeClipboard(age.model) #copies to clipboard
# write.csv(age.model, 'age.model.csv', row.names = FALSE)
## Just to show that depths.out can be random too and it also works
depths.out <- sort(rnorm(50))
age.model <- ageDepth.fn(ages.pointer = ages.pointer, depths.pointer = depths.pointer, depths.out = depths.out, plot.out = TRUE)
##### This is the inner workings of this #####
# ###########################################
# #   Functions to create age-depth models  #
# ###########################################
#
# #age model input (copy/pasted from excel...)
# # another way to copy/paste would be:
# # ages <- scan() # hit enter, then hit ctrl+v to paste whatever is on the clipboard.
# # Obviously you can also just call in a relevant csv file and name the objects/headers appropriately.
#
# ages.pointer <- readClipboard() # can really be any series to interpolate over a depth scale...
# depths.pointer <- readClipboard()
# depths.out <- readClipboard()
#
# agemodel <- approx(x = depths.pointer, y = ages.pointer, xout = depths.out)
# plot(agemodel)
# points(depths.pointer, ages.pointer, pch = 16, col = 'red')
#
# writeClipboard(as.character(agemodel$x)) # depths
# writeClipboard(as.character(agemodel$y)) # ages/calculated series
#
density_depths <- read_xlsx("/Users/icbissell/Desktop/density_depths.xlsx")
chas.depths.pointer <- as.numeric(unlist(density_depths[, "Mean_depth"]))
chas.density.pointer <- as.numeric(unlist(density_depths[, "Dry_density"]))
chas.depths.int <- as.numeric(unlist(density_depths[, "Wanted_depth"]))
ages.pointer
depths.pointer
chas.density.pointer <- na.omit(chas.density.pointer)
chas.density.pointer
chas.depths.pointer <- na.omit(chas.depths.pointer)
age.model <- ageDepth.fn(chas.density.pointer, chas.depths.pointer, chas.depths.int)
chas.depths.pointer <- as.numeric(unlist(density_depths[, "Mean_depth"]))
chas.density.pointer <- as.numeric(unlist(density_depths[, "Dry_density"]))
chas.density.pointer <- chas.density.pointer[1:92]
chas.depths.pointer <- chas.depths.pointer[1:92]
age.model <- ageDepth.fn(chas.density.pointer, chas.depths.pointer, chas.depths.int)
chas.depths.pointer
age.model <- ageDepth.fn(ages.pointer = chas.density.pointer, depths.pointer = chas.depths.pointer, depths.out = chas.depths.int, plot.out = TRUE)
View(age.model)
age.model[["age"]]
View(age.model)
age.model
age.model$age
density <- as.data.frame(age.model$age)
View(density)
write.csv(density)
pwd
write.csv(density, "/Users/icbissell/Desktop/density.csv")
title: "Intro to R"
---
title: "Intro to R"
knitr::opts_chunk$set(echo = TRUE)
xvec <- runif(10)
xvec
yvec <- runif(10)
plot(xvec, yvec)
#this does nothing at all
asdfd
3 + 4
a <- runif(10)
a
b <- runif(10)
c <- cbind(a, b)
c
glm(a,b)
xvec <- runif(10)
xvec
ls()
rm(xvec)
rm(a)
ls
ls()
v <- sample(1:9, 5, replace = TRUE)
v
set.seed(2)
v <- sample(1:9, 5, replace = TRUE)
v
v
v <- sample(1:9, 5, replace = TRUE)
v
v
v
xvec = c(1,2,3,4,5)
(xvec = c(1,2,3,4,5))
?pnorm()
pnorm(107.5, mean = 100, sd = 15)
1 - pnorm(107.5, mean = 100, sd = 15)
pnorm(70, mean = 100, sd = 15)
pnorm(130, mean = 100, sd = 15)  - pnorm(70, mean = 100, sd = 15)
pnorm(130, mean = 100, sd = 15)
1 - 0.9772499^2
1 - 0.9772499
pnorm(107.5, mean = 100, sd = 15)
1- pnorm(107.5, mean = 100, sd = 15)
(1 - 0.9772499^2)*0.3085375
knitr::opts_chunk$set(echo = TRUE)
#Will you take a COVID-19 vaccine when it's available?
#Here's our data:
Yes <- rep("Yes", 9)
No <- rep("No", 5)
No_Idea <- rep("No idea", 11)
survey <- c(Yes, No, No_Idea)
A <- rep("Yes", 6)
B <- rep("No", 5)
C <- rep("Yes", 7)
D <- rep("No", 7)
US <- c(A,B,C,D)
data <- data.frame(survey, US)
View(data)
#First, create a table of the data:
table(data)
#Will you take a COVID-19 vaccine when it's available?
#Here's our data:
Yes <- rep("Yes", 9)
No <- rep("No", 5)
No_Idea <- rep("No idea", 11)
survey <- c(Yes, No, No_Idea)
A <- rep("Yes", 6)
B <- rep("No", 5)
C <- rep("Yes", 7)
D <- rep("No", 7)
US <- c(A,B,C,D)
data <- data.frame(survey, US)
View(data)
#First, create a table of the data:
table(data)
pie(table(survey))
percentages <- prop.table(table(survey))
labels <- c("No", "No Idea", "Yes")
pie(percentages, cex.main = .75, labels = labels, main="Will you take a COVID-19 vaccine when it's available?")
?subset
barplot(survey)
barplot(tabl(survey)
barplot(table(survey)
counts <- table(survey)
barplot(counts)
counts <- table(data$survey, data$US)
counts
barplot(counts)
barplot(counts, cex.main = .75, ylim = range(c(0,20)), main = "Will you take a COVID-19 vaccine as soon as it becomes available?", xlab="Response")
data <- c(.1, .2, .5, 1, 1.7, 2.6, 4.0, 6.0, 9.5, 45)
#The handwritten boxplot should look like this:
boxplot(data, main = "Boxplot of Data", horizontal = TRUE)
COTININE <- read.csv("http://reuningscherer.net/stat10x/data/cotinine.csv", header = T)
#View(COTININE)
nrow(COTININE)
summary(COTININE)
mean(COTININE)
?mean
mean(COTININE$ETS)
SD(COTININE$ETS)
sd(COTININE$ETS)
?pnorm()
pnorm(0.95, mean(COTININE$ETS), sd(COTININE$ETS))
mean <- mean(COTININE$ETS)
SD <- sd(COTININE$ETS)
lower_bound <- mean - 2*SD
upper_bound <- mean + 2*SD
#Here's the lower bound:
lower_bound
#Here's the upper bound:
upper_bound
?barplot()
barplot(COTININE$SMOKER) + barplot(COTININE$ETS)
boxplot(COTININE$SMOKER) + boxplot(COTININE$ETS)
boxplot(COTININE$SMOKER)
boxplot(COTININE$ETS)
boxplot(COTININE)
?pnorm
pnorm(72.4, mean = 71.5, sd = 2.7)
pnorm(71.5, mean = 71.5, sd = 2.7)
pnorm(76, mean = 71.5, sd = 2.7)
pnorm(79.6, mean = 71.5, sd = 2.7)
pnorm(76, mean = 72.4, sd = 3.6)
pnorm(72.4, mean = 72.4, sd = 3.6)
pnorm(79.6, mean = 72.4, sd = 3.6)
pnorm(68.8, mean = 72.4, sd = 3.6)
clear
cl
knitr::opts_chunk$set(echo = TRUE)
library(ape)
phy = read.ftable("18s.aligned.fasta.treefile")
phy_2 = read.tree("alignment.fasta.treefile")
plot(phy_2)
phy_2 = read.tree("alignment.fasta.treefile")
phy_2 <- drop.tip(c(XR_002890936.1_Physeter_catodon))
phy_2 = read.tree("alignment.fasta.treefile")
#phy_2 <- drop.tip(c(XR_002890936.1_Physeter_catodon))
plot(phy_2)
phy_2 = read.tree("alignment.fasta.treefile")
phy_2 <- drop.tip(c(XR_002890936.1 Physeter catodon))
phy_2 = read.tree("alignment.fasta.treefile")
phy_2 <- drop.tip(c("XR_002890936.1_Physeter_catodon"))
phy_2 = read.tree("alignment.fasta.treefile")
phy_2 <- drop.tip(c("XR_002890936.1 Physeter catodon"))
phy_2 = read.tree("alignment.fasta.treefile")
phy_3 <- drop.tip(phy_2, c("XR_002890936.1_Physeter_catodon"))
plot(phy_3)
p
x <- seq(-10, 10, by = .01)
y <- dnorm(x, mean = 4, sd = 3.202)
plot(x,y)
pnorm(0, mean = 4, sd = 3.202)
1- pnorm(0, mean = 4, sd = 3.202)
dbinom(140, size = 250, prob = 0.5)
dbinom(125, size = 250, prob = 0.5)
probs = dbinom(c(0:250), 250, 0.5)
plot(c(0:250), probs)
pbinom(140, 250, 0.5)
1-pbinom(140, 250, 0.5)
exp = 250*0.5
var = 250*0.5*0.5
sd = sqrt(var)
z = (140-exp)/sd
10pnorm(z)
1-pnorm(z)
binom.test(140, 250, p = 0.5)
x = c(1:6)
y = (6^c/factorial(c))*exp(-6)
y = (power(6,c)/factorial(c))*exp(-6)
c
y = (power(6,x)/factorial(x))*exp(-6)
x
power(6,x)
6^x
y = ((6^x)/factorial(x))*exp(-6)
plot(x,y)
sum(y)
x = c(1:1000)
y = dnorm(x, mean = 54, sd = sqrt(54))
plot(x,y)
?seq
x = seq(0,200, by=0.1)
y = dnorm(x, mean = 54, sd = sqrt(54))
plot(x,y)
1 - pnorm(65, 54, sqrt(54))
1 - pnorm(65, 54, 54)
1/sqrt(1000)
1/sqrt(20)
pbinom(4, 5, 0.8)
1- dbinom(18, 20, 0.8)
dbinom(18, 20, 0.8)
dbinom(4, 5, 0.8)
1- pbinom(18, 20, 0.8)
dbinom(140, 250, 0.3)
dbinom(140, 250, 0.5)
pbinom(140, 250, 0.5)
?pbinom
1- pbinom(140, 250, 0.5)
1- dbinom(140, 250, 0.5)
dbinom(140, 250, 0.5)
1- pbinom(140, 250, 0.5)
pbinom(140, 250, 0.5)
pbinom(139, 250, 0.5)
1- pbinom(139, 250, 0.5)
1- pbinom(17, 20, 0.8)
1- pbinom(18, 20, 0.8)
dbinom(18, 20, 0.8)+dbinom(19, 20, 0.8)+dbinom(20, 20, 0.8)
?plot
library(ape)
?plot
?ape
rProp <- 38/380
iProp <- 246/573
prop.test(x = c(rProp, iProp), n = c(380, 573), conf.level = 0.95, correct = FALSE)
prop.test(x = c(rProp, iProp), n = c(380, 573), conf.level = .95, correct = FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(ape)
# Load data import, wrangling, and plotting tools from the Tidyverse.
# See https://r4ds.had.co.nz/ for more
library(tidyverse)
library(magrittr)
trace_jc =
read_tsv("output_jc/primates_cytb_JC.log")
trace_jc =
read_tsv("output_jc/primates_cytb_JC.log")
trace_jc =
read_tsv("output_jc/primates_cytb_JC.log")
trace_jc %<>%                           # Read the data
mutate(Replicate_ID = as.factor(Replicate_ID))                       # Convert the replicate id to a factor
trace_jc %<>% mutate(Iteration = Iteration %/% length(levels(trace_jc$Replicate_ID)))  # The iterations are sequenctial across all replicates. Rescale them so that they are in number of generations per replicate, rather than total number of samples
trace_jc %>%
ggplot(aes(x=Iteration, y=TL, col=Replicate_ID), alpha=0.2) + geom_line()
trace_jc %>%
ggplot(aes(x=Iteration, y=Likelihood, col=Replicate_ID), alpha=0.2) + geom_line()
trace_jc %>%
filter( Iteration > 2500 ) %>%
ggplot(aes(x=Iteration, y=TL, col=Replicate_ID), alpha=0.2) + geom_line()
trace_jc %>%
filter( Iteration > 2500 ) %>%
ggplot(aes(x=Iteration, y=Likelihood, col=Replicate_ID), alpha=0.2) + geom_line()
trace_jc %>%
filter( Iteration > 2500 ) %>%
ggplot(aes(TL, fill = Replicate_ID, colour = Replicate_ID)) +
geom_density(alpha = 0.1)
trace_jc %>%
filter( Iteration > 2500 ) %>%
ggplot(aes(Likelihood, fill = Replicate_ID, colour = Replicate_ID)) +
geom_density(alpha = 0.1)
trace_gtr =
read_tsv("output_gtr/primates_cytb_GTR.log")
trace_gtr %<>%                           # Read the data
mutate(Replicate_ID = as.factor(Replicate_ID))                       # Convert the replicate id to a factor
trace_gtr %>%
ggplot(aes(x=Iteration, y=TL, col=Replicate_ID), alpha=0.2) + geom_line()
trace_gtr =
read_tsv("output_gtr/primates_cytb_GTR.log")
trace_gtr %>%
ggplot(aes(x=Iteration, y=TL), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=Likelihood), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=TL), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=Likelihood), alpha=0.2) + geom_line()
trace_gtrig =
read_tsv("output_gtrig/primates_cytb_GTRGI.log")
trace_gtrig %>%
ggplot(aes(x=Iteration, y=TL), alpha=0.2) + geom_line()
trace_gtrig %>%
ggplot(aes(x=Iteration, y=Likelihood), alpha=0.2) + geom_line()
trace_gtrig %>%
ggplot(aes(x=Iteration, y=Alpha), alpha=0.2) + geom_line()
trace_gtrig %>%
ggplot(aes(x=Iteration, y=alpha), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=Prior), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=Likelihood), alpha=0.2) + geom_line()
trace_gtr %>%
ggplot(aes(x=Iteration, y=TL), alpha=0.2) + geom_line()
tinytex::install_tinytex()
library(stringr)
library(car)
library(ggplot2)
library(plyr)
library(zoo)
setwd("/Users/icbissell/Documents/research/Eocene_teeth/code/length_plot")
total_data <- read.csv("data/ToothMorph_V0.4_Morphotypes - Chas_U1553.csv")
#define function to cut matrix to right size
cut_to <- function(lengthID, total_data) {
#create shorter object ID to match between datasets
objID <- lengthID$ObjectID[1]
objId_cut <- sub("^(([^_]*_){5}[^_]*).*", "\\1", objID)
#Shorten large dataset to only those with object id
match_id <- total_data[grepl(objId_cut, total_data$Sample.ID, fixed = TRUE), ]
match_id <- match_id[match_id$Tooth.Dent == "1", ]
teeth <- data.frame(lengthID)
teeth <- teeth[0, ]
for(i in 1:length(match_id$Object)){
if("TRUE" %in% str_detect(lengthID$ObjectID, match_id$Object[i])) {
index <- lengthID$ObjectID[str_detect(lengthID$ObjectID, match_id$Object[i])]
teeth[nrow(teeth) + 1, ] = lengthID[which(lengthID$ObjectID == index), ]
}
}
return(teeth)
}
#prepare datasets
length_93 <- read.csv("data/93_morph2d_properties.csv")
length_95 <- read.csv("data/95_morph2d_properties.csv")
length_97 <- read.csv("data/97_morph2d_properties.csv")
length_99 <- read.csv("data/99_morph2d_properties.csv")
length_101_1 <- read.csv("data/101_1_morph2d_properties.csv")
length_101_2 <- read.csv("data/101_2_morph2d_properties.csv")
length_103 <- read.csv("data/103_morph2d_properties.csv")
length_105 <- read.csv("data/105_morph2d_properties.csv")
length_107 <- read.csv("data/107_morph2d_properties.csv")
length_109 <- read.csv("data/109_morph2d_properties.csv")
length_111 <- read.csv("data/111_morph2d_properties.csv")
length_113 <- read.csv("data/113_morph2d_properties.csv")
length_115_1 <- read.csv("data/115_1_morph2d_properties.csv")
length_115_2 <- read.csv("data/115_2_morph2d_properties.csv")
length_117 <- read.csv("data/117_morph2d_properties.csv")
length_119 <- read.csv("data/119_morph2d_properties.csv")
length_121_1 <- read.csv("data/121_1_morph2d_properties.csv")
length_121_2 <- read.csv("data/121_2_morph2d_properties.csv")
length_123 <- read.csv("data/123_morph2d_properties.csv")
length_125 <- read.csv("data/125_morph2d_properties.csv")
length_130_1 <- read.csv("data/130_1_morph2d_properties.csv")
length_130_2 <- read.csv("data/130_2_morph2d_properties.csv")
length_131 <- read.csv("data/131_morph2d_properties.csv")
length_133_1 <- read.csv("data/133_1_morph2d_properties.csv")
length_133_2 <- read.csv("data/133_2_morph2d_properties.csv")
length_135 <- read.csv("data/135_morph2d_properties.csv")
length_139 <- read.csv("data/139_morph2d_properties.csv")
length_143 <- read.csv("data/143_morph2d_properties.csv")
teeth_93 <- cut_to(length_93, total_data)
teeth_95 <- cut_to(length_95, total_data)
teeth_97 <- cut_to(length_97, total_data)
teeth_99 <- cut_to(length_99, total_data)
teeth_101_1 <- cut_to(length_101_1, total_data)
teeth_101_2 <- cut_to(length_101_2, total_data)
teeth_103 <- cut_to(length_103, total_data)
teeth_105 <- cut_to(length_105, total_data)
teeth_107 <- cut_to(length_107, total_data)
teeth_109 <- cut_to(length_109, total_data)
teeth_111 <- cut_to(length_111, total_data)
teeth_113 <- cut_to(length_113, total_data)
teeth_115_1 <- cut_to(length_115_1, total_data)
teeth_115_2 <- cut_to(length_115_2, total_data)
teeth_117 <- cut_to(length_117, total_data)
teeth_119 <- cut_to(length_119, total_data)
#remove one problematic tooth#
teeth_119 <- teeth_119[-which(teeth_119$ObjectID == "119_U1553D_4R_4W_20-23cm_N1of1_Z200x_obj00615_plane000"), ]
##############################
teeth_121_1 <- cut_to(length_121_1, total_data)
teeth_121_2 <- cut_to(length_121_2, total_data)
teeth_123 <- cut_to(length_123, total_data)
teeth_125 <- cut_to(length_125, total_data)
teeth_130_1 <- cut_to(length_130_1, total_data)
teeth_130_2 <- cut_to(length_130_2, total_data)
teeth_131 <- cut_to(length_131, total_data)
teeth_133_1 <- cut_to(length_133_1, total_data)
teeth_133_2 <- cut_to(length_133_2, total_data)
teeth_135 <- cut_to(length_135, total_data)
teeth_139 <- cut_to(length_139, total_data)
teeth_143 <- cut_to(length_143, total_data)
#combine multi-hole sections
teeth_101 <- rbind(teeth_101_1, teeth_101_2)
teeth_101["SampleID"] <- "101"
rm(teeth_101_1, teeth_101_2)
teeth_115 <- rbind(teeth_115_1, teeth_115_2)
teeth_115["SampleID"] <- "115"
rm(teeth_115_1, teeth_115_2)
teeth_121 <- rbind(teeth_121_1, teeth_121_2)
teeth_121["SampleID"] <- "121"
rm(teeth_121_1, teeth_121_2)
teeth_130 <- rbind(teeth_130_1, teeth_130_2)
teeth_130["SampleID"] <- "130"
rm(teeth_130_1, teeth_130_2)
teeth_133 <- rbind(teeth_133_1, teeth_133_2)
teeth_133["SampleID"] <- "130"
rm(teeth_133_1, teeth_133_2)
#combine all dfs into big frame
teeth_list <- mget(ls(pattern = "^teeth_*"))
teeth_total <- rbind.fill(teeth_list)
age <- aggregate(total_data$Age, list(total_data$Sample.ID), FUN = mean)
for(i in 1:length(age$Group.1)){
age$Group.1[i] <- sub("^(([^_]*_){0}[^_]*).*", "\\1", age$Group.1[i])
}
colnames(age)[1] = "SampleID"
colnames(age)[2] = "Age"
teeth_total <- merge(age, teeth_total, by.y = "SampleID", by.x = "SampleID")
teeth_total$length <- pmax(teeth_total$Height, teeth_total$Width)
length_means <- aggregate(teeth_total$length, list(teeth_total$Age), FUN = mean)
plot(length_means$Group.1, length_means$x)
#linear model from means
model <- lm(length_means$x ~ as.numeric(length_means$Group.1))
summary(model)
plot(length_means$Group.1, model$residuals, type = 'o', col= ifelse(model$residuals > 0, "red", ifelse(model$residuals < 0,"blue", "black")))
abline(h=0)
